<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Unscramble + Images</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    /* Background video */
    .bg-video {
      position: fixed;
      top: 50%;
      left: 60%;
      transform: translate(-50%, -50%) scaleX(0.8);
      width: calc(50vw - 2rem);
      height: calc(60vh - 2rem);
      object-fit: cover;
      object-position: center center;
      z-index: -1;
      pointer-events: none;
      display: none;
      filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      animation: videoFlicker 0.06s steps(1, end) infinite, hologramRoll 3s linear infinite, hologramGlitch 0.8s infinite;
      overflow: hidden;
    }
    
    /* Mobile video - 15% bigger */
    @media (max-width: 768px) {
      .bg-video {
        width: calc(57.5vw - 2rem); /* 50vw * 1.15 = 57.5vw */
        height: calc(69vh - 2rem);  /* 60vh * 1.15 = 69vh */
      }
    }
    
    /* Add hologram container for better effect control */
    .bg-video::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        0deg,
        transparent 0%,
        rgba(0, 255, 0, 0.1) 25%,
        rgba(0, 255, 0, 0.2) 50%,
        rgba(0, 255, 0, 0.1) 75%,
        transparent 100%
      );
      animation: verticalRoll 2s linear infinite;
      pointer-events: none;
      z-index: 1;
    }
    
    /* Video flicker animation */
    @keyframes videoFlicker {
      0% { filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2); }
      8% { filter: grayscale(1) brightness(0.58) contrast(1.25) sepia(1) hue-rotate(59deg) saturate(2.1); }
      15% { filter: grayscale(1) brightness(0.71) contrast(1.15) sepia(1) hue-rotate(61deg) saturate(1.9); }
      23% { filter: grayscale(1) brightness(0.55) contrast(1.28) sepia(1) hue-rotate(58deg) saturate(2.2); }
      31% { filter: grayscale(1) brightness(0.68) contrast(1.18) sepia(1) hue-rotate(62deg) saturate(1.8); }
      38% { filter: grayscale(1) brightness(0.61) contrast(1.22) sepia(1) hue-rotate(60deg) saturate(2.0); }
      46% { filter: grayscale(1) brightness(0.73) contrast(1.16) sepia(1) hue-rotate(61deg) saturate(1.9); }
      54% { filter: grayscale(1) brightness(0.57) contrast(1.26) sepia(1) hue-rotate(59deg) saturate(2.1); }
      62% { filter: grayscale(1) brightness(0.66) contrast(1.19) sepia(1) hue-rotate(60deg) saturate(2.0); }
      69% { filter: grayscale(1) brightness(0.59) contrast(1.24) sepia(1) hue-rotate(58deg) saturate(2.2); }
      77% { filter: grayscale(1) brightness(0.72) contrast(1.17) sepia(1) hue-rotate(62deg) saturate(1.8); }
      85% { filter: grayscale(1) brightness(0.62) contrast(1.21) sepia(1) hue-rotate(60deg) saturate(2.0); }
      92% { filter: grayscale(1) brightness(0.67) contrast(1.18) sepia(1) hue-rotate(61deg) saturate(1.9); }
      100% { filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2); }
    }
    
    /* Vertical roll displacement effect */
    @keyframes verticalRoll {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }
    
    /* Hologram rolling wave effect */
    @keyframes hologramRoll {
      0% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1);
        filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
      25% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1.02);
        filter: grayscale(1) brightness(0.68) contrast(1.15) sepia(1) hue-rotate(62deg) saturate(2.1);
      }
      50% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(0.98);
        filter: grayscale(1) brightness(0.6) contrast(1.25) sepia(1) hue-rotate(58deg) saturate(1.9);
      }
      75% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1.01);
        filter: grayscale(1) brightness(0.66) contrast(1.18) sepia(1) hue-rotate(61deg) saturate(2.05);
      }
      100% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1);
        filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
    }
    
    /* Hologram glitch effect */
    @keyframes hologramGlitch {
      0%, 90%, 100% { 
        transform: translate(-50%, -50%) scaleX(0.8);
        opacity: 1;
      }
      92% { 
        transform: translate(-50.1%, -50%) scaleX(0.8);
        opacity: 0.95;
      }
      94% { 
        transform: translate(-49.9%, -50.05%) scaleX(0.8);
        opacity: 0.98;
      }
      96% { 
        transform: translate(-50.05%, -49.95%) scaleX(0.8);
        opacity: 0.96;
      }
      98% { 
        transform: translate(-49.95%, -50%) scaleX(0.8);
        opacity: 0.97;
      }
    }
    
    
    
    /* Video overlay (disabled for small centered video) */
    .bg-overlay {
      display: none;
    }
    /* Your actual content goes above (z-index > 0) */
    .content {
      position: relative;
      z-index: 1;
      color: #e8e8e8;
      font: 16px/1.5 system-ui, sans-serif;
      padding: 6vmin;
    }
    html,body { height:100%; margin:0; background:#000; }

    /* Font Definitions */
    @font-face {
      font-family: 'IBM3270';
      src: url('fonts/fonts/3270-Regular.ttf') format('truetype'),
           url('fonts/fonts/3270-Regular.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'PixelCarnageMono';
      src: url('fonts/fonts/PixelCarnageMono.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Crisp';
      src: url('fonts/fonts/Crisp.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'ProggyCleanCE';
      src: url('fonts/fonts/ProggyCleanCE.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'ProggySquare';
      src: url('fonts/fonts/ProggySquare.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    :root { 
      --fg:#D4D4D4; 
      --bg:#000; 
      --accent:#00FF00; 
      --soft:#66FF66;
      --font-family: 'Crisp', 'IBM3270', 'Courier New', monospace;
    }
    html, body { height:100%; }
    
    /* FORCE NO SCROLLING */
    html {
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    
    body {
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background:var(--bg); 
      color:var(--fg); 
      font-family:var(--font-family);
      padding: 0;
      perspective: 1000px; 
      margin: 0;
      line-height:1.6; 
      user-select:none;
      font-size: 1rem;
      box-sizing: border-box;
    }
    
    /* CRT scanline effect */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(
0deg,
transparent 0px,
transparent 2px,
rgba(0, 255, 0, 0.03) 2px,
rgba(0, 255, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 99998;
    }
    
    /* Black scanlines on top */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(
0deg,
rgba(0, 0, 0, 0.26) 0px,
rgba(0, 0, 0, 0.26) 2px,
transparent 2px,
transparent 4px
      );
      pointer-events: none;
      z-index: 99999;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 0 !important;
        margin: 0 !important;
        font-size: 0.8rem;
        padding-left: 0 !important;
        max-width: 100% !important;
        width: 100% !important;
        left: 0 !important;
        right: 0 !important;
        overflow-x: hidden !important;
      }
      #page {
        padding: 1vh 2vw; /* Reduced horizontal padding */
        height: 70vh; /* Increased height for mobile */
        min-height: 25em;
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 !important;
        left: 0 !important;
        right: 0 !important;
        box-sizing: border-box !important;
        overflow-x: hidden !important;
      }
      #text-wrap {
        width: 100% !important; /* Force full width on mobile */
        max-width: 100% !important;
        margin-top: 0; /* Remove negative margin that was causing issues */
        height: calc(100% - 1rem); /* Adjust height calculation */
        padding: 1rem 1vw !important; /* Reduced padding to prevent overflow */
        box-sizing: border-box !important;
        overflow-x: hidden !important;
      }
      #unscramble {
        font-size: 0.8rem;
        line-height: 1.3;
        width: 100% !important; /* Force full width */
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
        box-sizing: border-box !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        white-space: pre-wrap !important;
        overflow-x: hidden !important;
        word-break: break-word !important; /* Force word breaking on mobile */
        hyphens: auto !important; /* Enable hyphenation on mobile */
      }
      #nav {
font-size: 0.9rem;
        margin: 0.3vh 0 0.3vh;
      }
      #nav-msg {
font-size: 0.6rem;
      }
      #slide-counter {
        font-size: 0.5rem;
        margin: 0.3vh 0;
      }
      #prompt {
        font-size: 0.7rem;
      }
      
      /* Mobile video sizing - much smaller on mobile */
      .bg-video {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scaleX(0.85);
        width: calc(95vw - 1rem);
        height: calc(70vh - 1rem);
        object-fit: contain;
        object-position: center center;
      }
      
      /* Force full width on mobile regardless of image mode */
      #text-wrap.side-mode,
      #text-wrap.small-side-mode {
        width: 100% !important;
        max-width: 100% !important;
        position: relative !important;
        z-index: 2 !important;
        padding: 1rem 1vw !important; /* Reduced padding to match main text-wrap */
        box-sizing: border-box !important;
        overflow-x: hidden !important;
      }
      
      #text-wrap.side-mode #unscramble,
      #text-wrap.small-side-mode #unscramble {
        width: 100% !important;
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
        box-sizing: border-box !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        white-space: pre-wrap !important;
        overflow-x: hidden !important;
        word-break: break-word !important; /* Force word breaking on mobile */
        hyphens: auto !important; /* Enable hyphenation on mobile */
      }
      
      /* Additional mobile constraints to prevent overflow */
      * {
        max-width: 100% !important;
        box-sizing: border-box !important;
      }
      
      /* Ensure no element can cause horizontal overflow */
      html, body, #page, #text-wrap, #unscramble {
        overflow-x: hidden !important;
        max-width: 100vw !important;
      }
    }
    
    @media screen and (min-resolution: 1dppx) {
            body {
        font-size: 1.0rem;
      }
    }
    #page {
      position:relative; 
      height: 60vh;
      min-height: 20em; 
      padding:2rem; 
      border-radius:10px;
      background-size:cover; 
      background-position:center; 
      background-repeat:no-repeat;
      overflow: visible; /* Allow text to be visible */
    }
    
 /* Simple image display */
     #page img {
       display: none;
       filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
       /* Grayscale + green tint: black stays black, white becomes green */
       /* Ensure all image formats including GIFs display properly */
       image-rendering: auto;
     }
     
   /* Special rule: dim only photo7 - REMOVED (was too dark) */
      
      /* Special rule: dim only photo23 */
      #page img[id="img-23"] {
filter: grayscale(1) brightness(0.32) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
      
      /* Special rule: make page 10 images darker */
      #page img[id^="img-10"] {
filter: grayscale(1) brightness(0.35) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
    
    #page img.show-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
      display: block;
    }
    
 #page img.show-below {
       display: block;
       margin-top: 1rem;
       max-height: 40%;
       max-width: 100%;
       object-fit: contain;
       position: relative;
       top: -12rem;
       z-index: -1;
     }
    
     #page img.show-side {
display: block;
position: absolute;
right: 0;
top: 0;
width: 50%;
height: 100%;
object-fit: cover;
z-index: 1;
      }
      
     #page img.show-small-side {
 display: block;
 position: absolute;
 right: 0;
 top: 0;
 width: 25%;
 height: 60%;
 object-fit: cover;
 z-index: 1;
       }
    
    /* Text container width is now controlled by JavaScript */
    
    /* Hide the default cursor */
    body {
      cursor: none;
    }
    
    /* Custom cursor element */
    #custom-cursor {
      position: fixed;
      width: 10px;
      height: 10px;
      background: var(--accent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      mix-blend-mode: difference;
      display: none;
    }

    /* Year styling - make years and year ranges larger */
    .year-text {
      font-size: 1.2em !important;
      font-weight: bold;
      color: #66FF66;
      text-shadow: 0 0 2px #66FF66, 0 0 12px #66FF66;
    }
    
    /* Video loading status */
    #video-loading {
      position: fixed;
      top: calc(100vh - 8rem);
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10001;
      text-align: center;
      pointer-events: none;
    }
    
    .loading-text {
      font-family: var(--font-family);
      font-size: 1.2rem;
      color: var(--soft);
      text-shadow: 0 0 2px var(--soft), 0 0 12px var(--soft);
      margin-bottom: 1.5rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    
    .loading-bar {
      width: 300px;
      height: 4px;
      background: rgba(102, 255, 102, 0.2);
      border: 1px solid var(--soft);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    
    .loading-progress {
      height: 100%;
      background: var(--soft);
      box-shadow: 0 0 4px var(--soft);
      width: 0%;
      transition: width 0.3s ease;
      animation: loadingPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes loadingPulse {
      0%, 100% { 
        opacity: 0.6;
        box-shadow: 0 0 4px var(--soft);
      }
      50% { 
        opacity: 1;
        box-shadow: 0 0 8px var(--soft), 0 0 16px var(--soft);
      }
    }
    
    /* Mobile loading status */
    @media (max-width: 768px) {
      .loading-text {
        font-size: 1rem;
      }
      .loading-bar {
        width: 250px;
        height: 3px;
      }
    }
    
 #text-wrap { 
       position: fixed;
       top: 0;
       left: 0;
       width: 100vw;
       height: 100vh;
       box-sizing: border-box;
       overflow: hidden;
       max-width: 100vw;
       padding: 2rem 2rem 6rem 4rem;
     }
     
     /* Mobile-specific text-wrap overrides */
     @media (max-width: 768px) {
       #text-wrap {
         margin-top: 0; /* Remove negative margin on mobile */
         height: calc(100% - 1rem); /* Better height calculation for mobile */
       }
     }
                    #unscramble { 
      white-space: pre-wrap; 
      font-size: 0.99rem;
      line-height: 1.5;
      word-wrap: break-word;
      overflow-wrap: break-word;
      height: 100%;
      overflow: hidden;
      width: 100%;
      box-sizing: border-box;
      max-width: 100%;
      /* Preserve original formatting - no text wrapping modifications */
      text-indent: 0;
      word-break: normal;
      hyphens: none;
    }
     
     /* Handle indented line wrapping - preserve indentation for continuation lines */
     #unscramble .indented-line {
       display: block;
       text-indent: 2em; /* Standard indentation */
     }
     
     #unscramble .continuation {
       display: block;
       text-indent: 2em; /* Same indentation as parent */
     }
    #prompt { 
      margin-top:1rem; 
      visibility:hidden; 
      white-space:pre-wrap; 
      line-height:1.3; 
      font-size: 0.9rem;
    }

    #nav { 
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 1vh 0 0.5vh; 
      font-size: 0.9rem;
      min-height: 5vh;
      position: relative;
      gap: 4vw;
    }
    
    /* Desktop - add padding to bring arrows in from edges */
    @media (min-width: 769px) {
      #nav {
        padding: 0 4rem;
      }
    }
    #nav span { cursor:pointer; user-select:none; padding:0 1em; }
          #nav-msg { 
      flex-grow:1; 
      text-align:center; 
      font-size:0.6rem;
      min-height: 1.5rem;
      visibility: hidden;
    }
    
    #slide-counter {
      position: relative;
      top: 0.5vh;
      left: 0;
      transform: none;
      font-size: 0.6rem;
      opacity: 1;
      color: var(--accent);
      text-shadow: 0 0 2px var(--accent), 0 0 12px var(--accent);
      font-family: var(--font-family);
      pointer-events: none;
      z-index: 1000;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      text-align: center;
      margin: 0.5vh 0;
    }
    
   /* Side mode: text on left, image on right */
      #text-wrap.side-mode {
width: 50% !important;
max-width: 50% !important;
position: relative !important;
z-index: 2 !important;
      }
      
     /* Small side mode: text on left, smaller image on right */
       #text-wrap.small-side-mode {
 width: 75% !important;
 max-width: 75% !important;
 position: relative !important;
 z-index: 2 !important;
       }
    
  #text-wrap.side-mode #unscramble {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
      padding-left: 2rem !important;
      padding-right: 2rem !important;
    }
    
    #text-wrap.small-side-mode #unscramble {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
      font-size: 1.0rem !important;
      line-height: 1.3 !important;
      padding-left: 2rem !important;
      padding-right: 2rem !important;
    }
    
    /* Prevent any formatting interference with timeline content */
    #unscramble[data-timeline="true"] {
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
      word-break: normal !important;
      line-height: 1.5 !important;
      letter-spacing: 0.05em !important;
      word-spacing: normal !important;
      padding-left: 2rem !important;
      padding-right: 2rem !important;
    }
    
    /* Collateral Murder video slide animation */
    #unscramble.collateral-murder-slide {
      animation: moveUpwards 3s ease-out forwards;
      position: relative;
      z-index: 10;
      padding-left: 2rem !important;
      padding-right: 2rem !important;
    }
    
    /* Ensure all unscramble elements have padding */
    #unscramble {
      padding-left: 2rem !important;
      padding-right: 2rem !important;
    }
    
    @keyframes moveUpwards {
      0% {
        transform: translateY(0);
      }
      100% {
        transform: translateY(-50vh);
      }
    }
    
    /* Scanline movement animation */
    @keyframes scanlineMove {
      0% {
        transform: translateY(-100vh);
      }
      100% {
        transform: translateY(100vh);
      }
    }
    
    /* Mobile styles for last slide image */
    @media (max-width: 768px) {
      #last-slide-image-container {
        max-width: 85vw !important;
        max-height: 75vh !important;
        width: 85vw !important;
        height: 75vh !important;
        min-width: 80vw !important;
        min-height: 70vh !important;
        transform: translate(-50%, -60%) !important;
      }
      #last-slide-image {
        width: 100% !important;
        height: 100% !important;
        object-fit: contain !important;
      }
    }
    
    /* Persistent text that stays on screen */
    #persistent-text {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 1000;
      pointer-events: none;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 2rem;
    }
    
    #persistent-text .text-content {
      color: var(--accent);
      font-family: var(--font-family);
      font-size: 2rem;
      text-align: center;
      font-weight: bold;
      text-shadow: 0 0 10px var(--accent);
    }
    
     

  </style>
</head>
<body>
  <!-- Background video for last page -->
  <video
    id="bg-video"
    class="bg-video"
    autoplay
    muted
    playsinline
    loop
    preload="metadata"
    poster="./assets/bg-poster.jpg"
    aria-hidden="true"
    tabindex="-1"
    disablepictureinpicture
    controlslist="nodownload noplaybackrate noptimizequality nodatachannel"
    volume="0"
    defaultMuted
  >
    <source src="VIDEOS/video15.mp4" type="video/mp4" />
    <source src="VIDEOS/video15.webm" type="video/webm" />
  </video>

  <video
    id="bg-video2"
    class="bg-video"
    autoplay
    muted
    playsinline
    loop
    preload="metadata"
    poster="./assets/bg-poster.jpg"
    aria-hidden="true"
    tabindex="-1"
    disablepictureinpicture
    controlslist="nodownload noplaybackrate noptimizequality nodatachannel"
    volume="0"
    defaultMuted
    style="display: none;"
  >
    <source src="VIDEOS/video2.mp4" type="video/mp4" />
  </video>

  <video
    id="bg-video3"
    class="bg-video"
    autoplay
    muted
    playsinline
    preload="metadata"
    aria-hidden="true"
    tabindex="-1"
    disablepictureinpicture
    controlslist="nodownload noplaybackrate noptimizequality nodatachannel"
    volume="0"
    defaultMuted
    style="display: none;"
  >
    <source src="HOLOGRAMJ.mp4" type="video/mp4" />
  </video>
  
  <audio
    id="obiwan-audio"
    preload="metadata"
    style="display: none;"
  >
    <source src="OBIWAN_REAL.mp4" type="audio/mp4" />
  </audio>

  <div class="bg-overlay" id="bg-overlay" style="display: none;"></div>

  <div id="page">
    <div id="text-wrap">
      <div id="unscramble"></div>
      <div id="prompt"></div>
    </div>
    
    <!-- Images will be added here dynamically -->
  </div>

  <div id="nav">
    <span id="nav-prev">&lt;</span>
    <span id="nav-msg"></span>
    <span id="nav-next">&gt;</span>
  </div>

  <div id="slide-counter">SLIDE 1 / 1</div>

  
  <!-- Custom cursor -->
  <div id="custom-cursor"></div>

  <script>
    /* ================== CONTENT ================== */
    const fullTextRaw = `
RECIPIENT: DORSEY.6BDM

EYES ONLY / NO FWD / 
NO DSTRO

SOURCE: CSF
FILE ID: 369-108-11






THE SIX BILLION DOLLAR
MAN


PRESS [F] FOR FULL SCREEN





A FILM BY EUGENE JARECKI


6BDM: JULIAN ASSANGE AND THE PRICE OF TRUTH




2006: 
  > JULIAN ASSANGE [JA] IS ALIGNED WITH CRYPTO AND CYPHERPUNK AGITATORS IN THE FIGHT FOR
  > DECENTRALIZATION, PRIVACY, AND FREEDOM OF INFORMATION.
  > JA BUILDS WIKILEAKS [WL], A SECURE PUBLISHING PLATFORM TO HELP WHISTLEBLOWERS BYPASS LEGACY MEDIA.
2010: 
  > WL RELEASES A CLASSIFIED INTERNAL U.S. MILITARY VIDEO, EXPOSING U.S. WAR CRIMES COMMITTED IN IRAQ. 
2011-2012: 
  > WL PUBLISHES 6 OF THE 10 LARGEST RELEASES OF SENSITIVE MATERIAL IN U.S. HISTORY.
  > UK AUTHORITIES CARRY OUT INTERPOL ARREST WARRANT. JA TAKES REFUGE IN ECUADORIAN EMBASSY, LONDON.
2017: 
  > JA FORCIBLY REMOVED FROM EMBASSY.
2017-2024: 
  > JA IS INMATE #A9379AY AT HMP BELMARSH, MAX. SEC. 
2024: 
  > US. DROPS 17/18 COUNTS AGAINST JA, DISMISSES CASE. 
  > JA RETURNED TO AUSTRALIA.




THE FAILED WAR ON JA IS A STORY THE WORLD NEEDS TO HEAR. BUT THIS WON'T HAPPEN WITHOUT A RADICAL RELEASE PLAN.

IN 2025, 6BDM WON THE CANNES FILM FESTIVAL AND FIRST-EVER GOLDEN GLOBE FOR DOCUMENTARY.
BUT NO STREAMER OR BROADCASTER WILL TOUCH IT.





IN THE MODE OF WL, 6BDM'S RELEASE WILL BYPASS TRADITIONAL MEDIA.

A LEADING INFLUENCER WILL INTERVIEW JA AND GUIDE TRAFFIC TO THE FILM BEHIND A PAYWALL.

TO PROMOTE THIS TO A GLOBAL AUDIENCE, WE SEEK TO RAISE A P&A ARSENAL FROM WITHIN THE CRYPTO/CYPHER WORLD

`;

    /* ================== AUDIO SYSTEM ================== */
    let audioContext = null;
    let audioEnabled = true; // Enable audio by default
    let debugMode = true;
    let currentAudio = null; // Track currently playing audio
    let audioVolume = 0.7; // Default volume level
    
    // Function to stop any currently playing audio
    function stopCurrentAudio() {
      if (currentAudio) {
        console.log('ðŸ›‘ Stopping current audio...');
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio.src = ''; // Clear the source
        currentAudio.load(); // Reset the audio element
        currentAudio = null;
      }
      
      // Stop any visualizers (disabled)
      stop3DVisualizer();
      
      // Also stop any other audio elements that might be playing
      const allAudioElements = document.querySelectorAll('audio');
      allAudioElements.forEach(audio => {
        if (!audio.paused) {
          audio.pause();
          audio.currentTime = 0;
        }
      });
    }
    
    
    
    
    
    // Visualizer variables (disabled)
    let visualizerScene = null;
    let visualizerCamera = null;
    let visualizerRenderer = null;
    let visualizerMesh = null;
    let visualizerUniforms = null;
    let visualizerAnalyser = null;
    let visualizerDataArray = null;
    let visualizerRunning = false;
    let visualizerComposer = null;

    // Visualizer functions (disabled)
    function init3DVisualizer() {
      // Disabled
    }

    function start3DVisualizer(audioElement) {
      // Disabled
    }

    function stop3DVisualizer() {
      // Disabled
    }

    function animate3DVisualizer() {
      // Disabled
    }

    // Mouse tracking for camera movement
    let mouseX = 0;
    let mouseY = 0;
    document.addEventListener('mousemove', function (e) {
      const windowHalfX = window.innerWidth / 2;
      const windowHalfY = window.innerHeight / 2;
      mouseX = (e.clientX - windowHalfX) / 100;
      mouseY = (e.clientY - windowHalfY) / 100;
      window.mouseX = mouseX;
      window.mouseY = mouseY;
    });

    // Test audio function
    function testAudio() {
      console.log('ðŸ§ª Testing audio playback...');
      const testAudio = new Audio('AUDIO/audio15.mp3');
      testAudio.volume = 0.7;
      
      testAudio.addEventListener('play', () => {
        console.log('âœ… Test audio started playing!');
      });
      
      testAudio.addEventListener('error', (e) => {
        console.error('âŒ Test audio error:', e);
      });
      
      testAudio.play().then(() => {
        console.log('âœ… Test audio playing successfully');
      }).catch(err => {
        console.log('âŒ Test audio play failed:', err.message);
        console.log('ðŸ”§ Error details:', err);
      });
    }

    // Video background functions
    function showVideoBackground() {
      console.log('ðŸŽ¬ Showing video15...');
      const video = document.getElementById('bg-video');
      
      if (video) {
        console.log('âœ… Video element found, showing...');
        
        video.style.setProperty('display', 'block', 'important');
        console.log('ðŸŽ¬ Video display set to block with !important');
        console.log('ðŸŽ¬ Video computed style:', window.getComputedStyle(video).display);
        
        // Ensure video is completely muted
        video.muted = true;
        video.volume = 0;
        video.defaultMuted = true;
        
        // Reset video to beginning for sync
        video.currentTime = 0;
        
        // Set up video event listeners
        const onCanPlay = () => {
          console.log('âœ… Video15 ready to play');
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        const onError = (e) => {
          console.log('âŒ Video15 failed to load:', e);
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        video.addEventListener('canplay', onCanPlay);
        video.addEventListener('error', onError);
        
        video.play().then(() => {
          console.log('âœ… Video15 playing from start (muted)');
          console.log('ðŸŽ¬ Video15 dimensions:', video.videoWidth, 'x', video.videoHeight);
          console.log('ðŸŽ¬ Video15 position:', video.getBoundingClientRect());
        }).catch(err => {
          console.log('âŒ Video15 play failed:', err.message);
        });
      } else {
        console.error('âŒ Video element not found!');
      }
    }

    function hideVideoBackground() {
      console.log('ðŸ›‘ Hiding video...');
      const video = document.getElementById('bg-video');
      
      if (video) {
        video.pause();
        video.style.setProperty('display', 'none', 'important');
      }
    }

    // Video2 background functions
    function showVideo2Background() {
      console.log('ðŸŽ¬ Showing video2...');
      const video = document.getElementById('bg-video2');
      
      if (video) {
        console.log('âœ… Video2 element found, showing...');
        
        video.style.setProperty('display', 'block', 'important');
        console.log('ðŸŽ¬ Video2 display set to block with !important');
        console.log('ðŸŽ¬ Video2 computed style:', window.getComputedStyle(video).display);
        
        // Ensure video is completely muted
        video.muted = true;
        video.volume = 0;
        video.defaultMuted = true;
        
        // Reset video to beginning for sync
        video.currentTime = 0;
        
        // Set up video event listeners
        const onCanPlay = () => {
          console.log('âœ… Video2 ready to play');
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        const onError = (e) => {
          console.log('âŒ Video2 failed to load:', e);
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        video.addEventListener('canplay', onCanPlay);
        video.addEventListener('error', onError);
        
        video.play().then(() => {
          console.log('âœ… Video2 playing from start (muted)');
          console.log('ðŸŽ¬ Video2 dimensions:', video.videoWidth, 'x', video.videoHeight);
          console.log('ðŸŽ¬ Video2 position:', video.getBoundingClientRect());
        }).catch(err => {
          console.log('âŒ Video2 play failed:', err.message);
        });
      } else {
        console.error('âŒ Video2 element not found!');
      }
    }

    function hideVideo2Background() {
      console.log('ðŸ›‘ Hiding video2...');
      const video = document.getElementById('bg-video2');
      
      if (video) {
        video.pause();
        video.style.setProperty('display', 'none', 'important');
      }
    }

    // Unlock audio context on user interaction
    function unlockAudioContext() {
      if (!audioContextUnlocked) {
        console.log('ðŸ”“ Unlocking audio context...');
        
        // Enable audio if not already enabled
        if (!audioEnabled) {
          audioEnabled = true;
          console.log('ðŸ”Š Audio enabled on first interaction');
        }
        
        // Initialize audio context first
        initAudioContext();
        
        // Create a silent audio to unlock the context
        const audio = document.getElementById('obiwan-audio');
        if (audio) {
          audio.muted = true;
          audio.play().then(() => {
            audio.pause();
            audio.muted = false;
            audio.currentTime = 0;
            audioContextUnlocked = true;
            console.log('âœ… Audio context unlocked');
          }).catch(err => {
            console.log('âŒ Audio unlock failed:', err.message);
            // Fallback: try to unlock with Web Audio API
            if (audioContext && audioContext.state === 'suspended') {
              audioContext.resume().then(() => {
                audioContextUnlocked = true;
                console.log('âœ… Audio context unlocked via resume');
              }).catch(resumeErr => {
                console.log('âŒ Audio context resume failed:', resumeErr.message);
              });
            }
          });
        } else {
          // Fallback: try to unlock with Web Audio API only
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              audioContextUnlocked = true;
              console.log('âœ… Audio context unlocked via resume (no audio element)');
            }).catch(resumeErr => {
              console.log('âŒ Audio context resume failed:', resumeErr.message);
            });
          }
        }
      }
    }


    // Video3 (JA_OBIWAN) functions - with audio that stops when slide changes
    function showVideo3Background() {
      console.log('ðŸŽ¬ Showing JA_OBIWAN hologram video with audio...');
      const video = document.getElementById('bg-video3');
      const audio = document.getElementById('obiwan-audio');
      
      if (video) {
        // Show video immediately
        video.style.setProperty('display', 'block', 'important');
        video.muted = true;   // Keep video muted
        video.loop = true;    // Video loops visually
        video.currentTime = 0;
        
        // Set up video event listeners
        const onCanPlay = () => {
          console.log('âœ… Video3 ready to play');
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        const onError = (e) => {
          console.log('âŒ Video3 failed to load:', e);
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        video.addEventListener('canplay', onCanPlay);
        video.addEventListener('error', onError);
        
        video.play().catch(err => {
          console.log('Video3 play failed:', err.message);
        });
      }
      
      if (audio) {
        audio.volume = 0.7;   // Set audio volume
        audio.muted = false;  // Ensure not muted
        audio.currentTime = 0;
        
        // Try to play with better error handling
        console.log('ðŸ”Š Attempting to play audio...');
        audio.play().then(() => {
          console.log('âœ… Audio playing successfully');
        }).catch(err => {
          console.log('âŒ Audio play failed:', err.message);
          console.log('ðŸ”§ This might require user interaction first');
        });
      }
    }

    function hideVideo3Background() {
      console.log('ðŸ›‘ Hiding JA_OBIWAN video and stopping audio...');
      const video = document.getElementById('bg-video3');
      const audio = document.getElementById('obiwan-audio');
      
      if (video) {
        video.pause();
        video.style.setProperty('display', 'none', 'important');
      }
      
      if (audio) {
        audio.pause();
        audio.currentTime = 0; // Reset to beginning
      }
    }
    
    // Enhanced audio context initialization with debugging
    function initAudioContext() {
      if (debugMode) console.log('ðŸ”Š Initializing audio context...');
      
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          console.log('âœ… Audio context created successfully:', audioContext.state);
          
          // Resume audio context if suspended (required by Chrome)
          if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('âœ… Audio context resumed from suspended state');
            }).catch(err => {
              console.error('âŒ Failed to resume audio context:', err);
            });
          }
        } catch (e) {
          console.error('âŒ Audio context creation failed:', e);
          audioEnabled = false;
          showAudioError('Audio not supported in this browser');
        }
      }
      return audioContext !== null;
    }
    
    // Show audio error in the UI
    function showAudioError(message) {
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = `AUDIO ERROR: ${message}`;
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#FF6666';
        
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 3000);
      }
    }
    
    
    
    
    


    // Enhanced audio function for page 8
    function playAudioForPage8() {
      console.log('ðŸŽµ Attempting to play audio for page 8...');
      
      if (!audioEnabled) {
        console.log('ðŸ”‡ Audio disabled, skipping');
        return;
      }
      
      // Stop any current audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      
      // Create new audio with better error handling
      const audio = new Audio();
      audio.src = 'AUDIO/audio7.mp3';
      audio.volume = audioVolume;
      audio.preload = 'auto';
      
      console.log('ðŸŽµ Audio source:', audio.src);
      console.log('ðŸŽµ Audio volume:', audioVolume);
      console.log('ðŸŽµ Audio enabled:', audioEnabled);
      
      // Multiple event listeners for better compatibility
      audio.addEventListener('loadstart', () => {
        console.log('ðŸ”„ Audio loading started');
      });
      
      audio.addEventListener('loadeddata', () => {
        console.log('ðŸ“Š Audio data loaded');
      });
      
      audio.addEventListener('canplay', () => {
        console.log('â–¶ï¸ Audio can play');
        currentAudio = audio;
        audio.play().then(() => {
          console.log('âœ… Audio playing for page 8');
        }).catch(err => {
          console.error('âŒ Audio play failed:', err);
          console.error('âŒ Error details:', err.message);
          showAudioError('Audio play failed: ' + err.message);
        });
      });
      
      audio.addEventListener('error', (e) => {
        console.error('âŒ Audio load failed:', e);
        console.error('âŒ Audio src was:', audio.src);
        console.error('âŒ Error code:', audio.error ? audio.error.code : 'unknown');
        showAudioError('Audio file not found or corrupted');
      });
      
      // Force load
      audio.load();
    }

    // Enhanced audio function for page 12
    function playAudioForPage12() {
      console.log('ðŸŽµ Attempting to play audio for page 12...');
      
      if (!audioEnabled) {
        console.log('ðŸ”‡ Audio disabled, skipping');
        return;
      }
      
      // Stop any current audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      
      // Create new audio with better error handling
      const audio = new Audio();
      audio.src = 'AUDIO/audio9.mp3';
      audio.volume = audioVolume;
      audio.preload = 'auto';
      
      console.log('ðŸŽµ Audio source:', audio.src);
      console.log('ðŸŽµ Audio volume:', audioVolume);
      console.log('ðŸŽµ Audio enabled:', audioEnabled);
      
      // Multiple event listeners for better compatibility
      audio.addEventListener('loadstart', () => {
        console.log('ðŸ”„ Audio loading started');
      });
      
      audio.addEventListener('loadeddata', () => {
        console.log('ðŸ“Š Audio data loaded');
      });
      
      audio.addEventListener('canplay', () => {
        console.log('â–¶ï¸ Audio can play');
        currentAudio = audio;
        audio.play().then(() => {
          console.log('âœ… Audio playing for page 12');
        }).catch(err => {
          console.error('âŒ Audio play failed:', err);
          console.error('âŒ Error details:', err.message);
          showAudioError('Audio play failed: ' + err.message);
        });
      });
      
      audio.addEventListener('error', (e) => {
        console.error('âŒ Audio load failed:', e);
        console.error('âŒ Audio src was:', audio.src);
        console.error('âŒ Error code:', audio.error ? audio.error.code : 'unknown');
        showAudioError('Audio file not found or corrupted');
      });
      
      // Force load
      audio.load();
    }

    /* ================== PREP ================== */
    const fullText = fullTextRaw.toUpperCase();
    const pages = fullText.split(/\n{4,}/).filter(page => page.trim().length > 0);
    console.log('ðŸ“„ Page 2 content:', pages[1] ? pages[1].substring(0, 100) : 'UNDEFINED');
    console.log('ðŸ“„ Total pages created:', pages.length);
    console.log('ðŸ“„ Pages:', pages.map((p, i) => `Page ${i + 1}: ${p.substring(0, 50)}...`));
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,\'"?!-â€”:;\n';

 // Image modes
     const IMG_OFF = 0;
     const IMG_BG = 1;
     const IMG_BELOW = 2;
     const IMG_SIDE = 3;
     const IMG_SMALL_SIDE = 4;
    
    // Helper functions for cycling through image modes
    function getNextImageMode(currentMode) {
      const modes = [IMG_OFF, IMG_BG, IMG_BELOW, IMG_SIDE, IMG_SMALL_SIDE];
      const currentIndex = modes.indexOf(currentMode);
      return modes[(currentIndex + 1) % modes.length];
    }
    
    function getPreviousImageMode(currentMode) {
      const modes = [IMG_OFF, IMG_BG, IMG_BELOW, IMG_SIDE, IMG_SMALL_SIDE];
      const currentIndex = modes.indexOf(currentMode);
      return modes[(currentIndex - 1 + modes.length) % modes.length];
    }
    
    function markUserSetMode(pageIndex) {
      const pageNumber = pageIndex + 1;
      const imgEl = document.getElementById(`img-${pageNumber}`);
      if (imgEl) {
imgEl.setAttribute('data-user-set', 'true');
      }
      // Save to localStorage for persistence across refreshes
      savePageModeToStorage(pageIndex, pageModes[pageIndex]);
    }
    
    function savePageModeToStorage(pageIndex, mode) {
      try {
const storedModes = JSON.parse(localStorage.getItem('pitchDeckImageModes') || '{}');
storedModes[pageIndex] = mode;
localStorage.setItem('pitchDeckImageModes', JSON.stringify(storedModes));
      } catch (e) {
console.warn('Could not save image mode to localStorage:', e);
      }
    }
    
    function loadPageModesFromStorage() {
      try {
const storedModes = JSON.parse(localStorage.getItem('pitchDeckImageModes') || '{}');
Object.keys(storedModes).forEach(pageIndex => {
  const index = parseInt(pageIndex);
  if (index >= 0 && index < pageModes.length) {
    pageModes[index] = storedModes[pageIndex];
    // Mark as user-set so auto-detection doesn't override
    setTimeout(() => {
      const imgEl = document.getElementById(`img-${index + 1}`);
      if (imgEl) {
imgEl.setAttribute('data-user-set', 'true');
      }
    }, 100);
  }
});
      } catch (e) {
console.warn('Could not load image modes from localStorage:', e);
      }
    }
    
 const pageModes = new Array(pages.length).fill(IMG_BG); // Default to background image mode for all pages
    
    
    // Load saved image modes from localStorage
    loadPageModesFromStorage();
    
    // Disable keyword scanning completely for faster loading
    console.log('Image keyword scanning disabled - no images available');
    
    // Skip all image scanning since no images are available
    // This prevents the slow startup delay
    
    // Debug function - call from browser console: testImage('ignorant')
    window.testImage = function(keyword) {
      console.log(`Testing image for keyword: ${keyword}`);
      const img = document.createElement('img');
      img.src = `photos/photo_${keyword}.webp`;
      img.onload = () => {
        console.log(`âœ… Image loaded: photos/photo_${keyword}.webp`);
        availableKeywords.add(keyword);
        console.log('Available keywords:', Array.from(availableKeywords));
      };
      img.onerror = () => {
        console.log(`âŒ Image failed: photos/photo_${keyword}.webp`);
      };
    };
    
    // Debug function - test audio 8
    window.testAudio8 = function() {
      console.log('ðŸŽµ Testing audio 8...');
      playAudioForPage8();
    };
    
    // Debug function - test audio 12
    window.testAudio12 = function() {
      console.log('ðŸŽµ Testing audio 12...');
      playAudioForPage12();
    };
    
    // Simple test function for audio 8
    window.testAudio7Simple = function() {
      console.log('ðŸŽµ Testing audio7.mp3...');
      const audio = new Audio('AUDIO/audio7.mp3');
      audio.volume = 0.7;
      audio.play().then(() => {
        console.log('âœ… Audio7 playing successfully');
      }).catch(err => {
        console.log('âŒ Audio7 failed:', err.message);
      });
    };
    
    // Simple test function for audio 15
    window.testAudio15Simple = function() {
      console.log('ðŸŽµ Testing audio15.mp3...');
      const audio = new Audio('AUDIO/audio15.mp3');
      audio.volume = 0.7;
      audio.play().then(() => {
        console.log('âœ… Audio15 playing successfully');
      }).catch(err => {
        console.log('âŒ Audio15 failed:', err.message);
      });
    };
    
    // Test visualizer function
    window.testVisualizer = function() {
      console.log('ðŸŽ¨ Testing visualizer...');
      const canvas = document.getElementById('audio-visualizer');
      if (canvas) {
        canvas.style.display = 'block';
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'red';
        ctx.fillRect(100, 100, 200, 200);
        console.log('âœ… Visualizer test - red square should appear');
      } else {
        console.error('âŒ Canvas not found');
      }
    };
    

    // DOM
    const pageEl = document.getElementById('page');
    const textWrap = document.getElementById('text-wrap');
    const el = document.getElementById('unscramble');
    const promptElem = document.getElementById('prompt');
    const navMsg = document.getElementById('nav-msg');
    const slideCounterEl = document.getElementById('slide-counter');

    let currentPage = 0;
    let isAnimating = false;
    let currentInterval = null;
    let availableKeywords = new Set(); // Store available photo keywords
    let audioTimeout = null; // Track audio timeout
    let lineRevealTimeouts = []; // Track line reveal timeouts
    let isInLineRevealMode = false;
    let lineRevealState = { lines: [], currentIndex: 0, element: null, onComplete: null };
    let lastTouchTime = 0; // Track last touch time to prevent double-firing
    let filmByTimeouts = []; // Track 6BDM animation timeouts
    let currentTypingInterval = null; // Track the current subtitle typing interval
    let shouldContinueTyping = true; // Flag to control if typing should continue
    let timelineRevealState = { sections: [], currentIndex: 0, element: null, onComplete: null };
    let isInTimelineRevealMode = false;
    let audioContextUnlocked = false; // Track if audio context is unlocked

    // Test if a specific photo file exists
    function testPhotoExists(keyword, format) {
      return new Promise((resolve) => {
        const testImg = new Image();
        const timeout = setTimeout(() => {
          resolve(false);
        }, 1000);
        
        testImg.onload = () => {
          clearTimeout(timeout);
          resolve(true);
        };
        testImg.onerror = () => {
          clearTimeout(timeout);
          resolve(false);
        };
        testImg.src = `photos/photo_${keyword}.${format}`;
      });
    }

    // Scan photos folder to find available photo_keyword files
    async function scanAvailableKeywords() {
      const formats = ['webp', 'jpg', 'jpeg', 'png', 'gif'];
      const keywords = new Set();
      
      // Common keywords to test based on the content
      const testKeywords = [
        'ignorant', 'assange', 'wikileaks', 'bitcoin', 'crypto', 'cryptocurrency', 'blockchain',
        'surveillance', 'privacy', 'freedom', 'journalism', 'truth', 'transparency',
        'government', 'state', 'power', 'control', 'censorship', 'propaganda',
        'war', 'military', 'diplomacy', 'leaks', 'documents', 'secrets',
        'collateral', 'murder', 'video', 'footage', 'evidence',
        'prosecution', 'trial', 'prison', 'embassy', 'asylum', 'extradition',
        'moreno', 'ecuador', 'britain', 'america', 'cia', 'fbi', 'nsa',
        'cypherpunk', 'anonymity', 'encryption', 'decentralization', 'resistance',
        'activist', 'whistleblower', 'expose', 'revelation', 'scandal', 'corruption'
      ];
      
      console.log('Scanning for available photo keywords...');
      
      // First, test photo_ignorant.webp specifically
      console.log('ðŸ” Testing photo_ignorant.webp specifically...');
      const ignorantExists = await testPhotoExists('ignorant', 'webp');
      console.log(`photo_ignorant.webp exists: ${ignorantExists}`);
      
      // Test each keyword with each format
      for (const keyword of testKeywords) {
        let found = false;
        for (const format of formats) {
          const exists = await testPhotoExists(keyword, format);
          if (exists) {
            keywords.add(keyword);
            console.log(`âœ… Found: photo_${keyword}.${format}`);
            found = true;
            break; // Found this keyword, move to next
          } else {
            console.log(`âŒ Not found: photo_${keyword}.${format}`);
          }
        }
        if (!found) {
          console.log(`âŒ No photo found for keyword: ${keyword}`);
        }
      }
      
      availableKeywords = keywords;
      
      // Manual override for testing - force add "ignorant" if it exists
      const ignorantTest = await testPhotoExists('ignorant', 'webp');
      if (ignorantTest) {
        availableKeywords.add('ignorant');
        console.log('âœ… Manually added "ignorant" to available keywords');
      }
      
      console.log(`Available photo keywords:`, Array.from(keywords));
      return keywords;
    }

    // Extract keywords from page text that have corresponding photo files
    function extractKeywords(pageText) {
      // Convert to lowercase and extract meaningful words
      const words = pageText.toLowerCase()
        .replace(/[^\w\s]/g, ' ') // Remove punctuation
        .split(/\s+/)
        .filter(word => word.length > 3) // Only words longer than 3 characters
        .filter(word => !['that', 'this', 'with', 'from', 'they', 'have', 'been', 'were', 'said', 'will', 'would', 'could', 'should', 'about', 'above', 'below', 'under', 'over', 'through', 'during', 'before', 'after', 'while', 'since', 'until', 'unless', 'because', 'although', 'though', 'however', 'therefore', 'moreover', 'furthermore', 'nevertheless', 'nonetheless'].includes(word)) // Filter out common words
        .filter(word => availableKeywords.has(word)); // Only return words that have corresponding photo files
      
      return [...new Set(words)]; // Remove duplicates
    }

    // Simple image function - disabled for performance (no images available)
    function showImage(pageIndex) {
      // Hide all existing images first
      document.querySelectorAll('#page img').forEach(img => {
img.className = '';
      });
      
      // Skip image loading entirely since no images are available
      console.log(`ðŸ“· Image loading skipped for page ${pageIndex + 1} - no images available`);
      
      let imgEl = null; // No image element since none exist
      
      // Since no images exist, always use IMG_OFF mode for text layout
adjustTextContainerWidth(IMG_OFF);
    }
    
    
    // Adjust text container when side image is active
    function adjustTextForSideImage() {
      adjustTextContainerWidth(IMG_SIDE);
    }
    
    // Reset text container when image is turned off
    function resetTextContainer() {
      adjustTextContainerWidth(IMG_OFF);
    }
    
    // Adjust text container width based on image mode
    function adjustTextContainerWidth(imageMode) {
      const textWrap = document.getElementById('text-wrap');
      if (!textWrap) return;
      
   if (imageMode === IMG_SIDE) {
  // Side mode: text on left, image on right
  textWrap.style.setProperty('width', '50%', 'important');
  textWrap.style.setProperty('max-width', '50%', 'important');
  textWrap.style.setProperty('position', 'relative', 'important');
  textWrap.style.setProperty('z-index', '2', 'important');
  textWrap.classList.add('side-mode');
  textWrap.classList.remove('small-side-mode');
 } else if (imageMode === IMG_SMALL_SIDE) {
   // Small side mode: text on left, smaller image on right
   textWrap.style.setProperty('width', '75%', 'important');
   textWrap.style.setProperty('max-width', '75%', 'important');
   textWrap.style.setProperty('position', 'relative', 'important');
   textWrap.style.setProperty('z-index', '2', 'important');
   textWrap.classList.add('small-side-mode');
   textWrap.classList.remove('side-mode');
 } else {
  // All other modes: text uses full width
  textWrap.style.setProperty('width', '100%', 'important');
  textWrap.style.setProperty('max-width', '100%', 'important');
  textWrap.style.setProperty('position', '', 'important');
  textWrap.style.setProperty('z-index', '', 'important');
  textWrap.classList.remove('side-mode');
  textWrap.classList.remove('small-side-mode');
}
    }
    
    
    // Create image for a page number - tries multiple formats and naming patterns
    function createImageForPage(pageNumber) {
      const img = document.createElement('img');
      img.id = `img-${pageNumber}`;
      img.alt = `Page ${pageNumber} Image`;
      
      // Start invisible - only show when successfully loaded
      img.style.opacity = '0';
      img.style.transition = 'opacity 0.2s ease-in-out';
      
      // Add to page first (invisible)
      document.getElementById('page').appendChild(img);
      
      // Try to find any image that starts with the page number
      findImageForPage(img, pageNumber);
      
      // Only show image when it loads successfully
      img.addEventListener('load', () => {
        console.log(`Image loaded successfully for page ${pageNumber}`);
        img.style.opacity = '0.765';

        // Update page mode and layout if this is the current page
        const pageIndex = pageNumber - 1;
        if (pageIndex === currentPage) {
          adjustTextContainerWidth(pageModes[pageIndex]);
        }

        // Apply current overlay mode to new image
        applyOverlayToImage(img, currentOverlayMode);
      });
      
      // Handle image loading errors gracefully
      img.addEventListener('error', () => {
        console.log(`Failed to load image for page ${pageNumber}`);
        img.style.display = 'none';
      });
      
      return img;
    }
    
    // Find any image that starts with the page number
    function findImageForPage(img, pageNumber) {
      const formats = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'tiff', 'tif', 'avif', 'jfif', 'pjpeg'];
      
      // Try different naming patterns for this page number
      const namingPatterns = [
        `photo${pageNumber}`,           // photo10.jpg
        `picture${pageNumber}`,         // picture10.jpg
        `photo${pageNumber}_collateral`, // photo10_collateral.jpg
        `picture${pageNumber}_collateral`, // picture10_collateral.jpg
        `photo${pageNumber}_`,          // photo10_anything.jpg
        `picture${pageNumber}_`         // picture10_anything.jpg
      ];
      
      // Try each naming pattern with each format
      for (const pattern of namingPatterns) {
        for (const format of formats) {
          const testSrc = `photos/${pattern}.${format}`;
          const testImg = new Image();
          
          testImg.onload = function() {
            console.log(`âœ… Found working image: ${testSrc}`);
            img.src = testSrc;
            return; // Stop trying once we find one
          };
          
          testImg.onerror = function() {
            // Continue trying other patterns/formats
          };
          
          testImg.src = testSrc;
        }
      }
      
      // If no specific pattern worked, try a more general approach
      // This will try to find any file that starts with the page number
      setTimeout(() => {
        if (!img.src) {
          console.log(`Trying general search for page ${pageNumber}...`);
          tryGeneralImageSearch(img, pageNumber, formats);
        }
      }, 100);
    }
    
    // Try to find any image file that starts with the page number
    function tryGeneralImageSearch(img, pageNumber, formats) {
      // Common prefixes to try
      const prefixes = ['photo', 'picture', 'img', 'image'];
      
      for (const prefix of prefixes) {
        for (const format of formats) {
          // Try exact match first
          const exactSrc = `photos/${prefix}${pageNumber}.${format}`;
          const testImg = new Image();
          
          testImg.onload = function() {
            console.log(`âœ… Found working image (exact): ${exactSrc}`);
            img.src = exactSrc;
            return;
          };
          
          testImg.onerror = function() {
            // Try with underscore and common suffixes
            const suffixes = ['_collateral', '_murder', '_video', '_footage', '_evidence'];
            for (const suffix of suffixes) {
              const suffixSrc = `photos/${prefix}${pageNumber}${suffix}.${format}`;
              const suffixTestImg = new Image();
              
              suffixTestImg.onload = function() {
                console.log(`âœ… Found working image (with suffix): ${suffixSrc}`);
                img.src = suffixSrc;
                return;
              };
              
              suffixTestImg.onerror = function() {
                // Continue trying
              };
              
              suffixTestImg.src = suffixSrc;
            }
          };
          
          testImg.src = exactSrc;
        }
      }
    }

    // Create image for keyword-based matching
    function createImageForKeyword(keyword) {
      const img = document.createElement('img');
      img.id = `img-${keyword}`;
      img.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
height: 100%;
        object-fit: cover;
        z-index: -1;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
      `;
      
      // Try different image formats for the keyword
      tryImageFormats(img, keyword, 0);
      
      // Only show image when it loads successfully
      img.addEventListener('load', () => {
        console.log(`Image loaded successfully for keyword: ${keyword}`);
        img.style.opacity = '0.765';

        // Update page mode and layout if this is the current page
        const pageIndex = currentPage;
        if (pageIndex === currentPage) {
          adjustTextContainerWidth(pageModes[pageIndex]);
        }

        // Apply current overlay mode to new image
        applyOverlayToImage(img, currentOverlayMode);
      });

      // Handle image loading errors gracefully
      img.addEventListener('error', () => {
        console.log(`Failed to load image for keyword: ${keyword}`);
        img.style.display = 'none';
      });

      return img;
    }


         // Universal image support - tries all possible formats
     function tryImageFormats(img, keyword, formatIndex) {
       
       // Start with most compatible formats, then try everything else
       const formats = [
 'jpg', 'jpeg', 'png', 'gif',  // Universal support
 'webp', 'svg',// Modern browsers
 'bmp', 'tiff', 'tif', // Desktop browsers
 'avif', 'jfif', 'pjpeg'       // Newer formats
       ];
       
       if (formatIndex >= formats.length) {
 // All formats failed, remove the image
 console.log(`No image found for keyword '${keyword}'`);
 img.remove();
 return;
       }
       
       const format = formats[formatIndex];
       const testSrc = `photos/photo_${keyword}.${format}`;
       
       // Test if this format file exists by creating a test image
       const testImg = new Image();
       testImg.onload = function() {
 // File exists and format is supported - use it!
 console.log(`âœ… Found working image: ${testSrc}`);
 img.src = testSrc;
       };
       testImg.onerror = function() {
 // This format/file doesn't work, try next
 tryImageFormats(img, keyword, formatIndex + 1);
       };
       testImg.src = testSrc;
     }

    
      function truncateTextToFit(element, text) {
      // Simply set the content without dynamic page splitting
      element.textContent = text;
      }

    /* ================== SCRAMBLE ================== */
    
    // Function to type subtitle text character by character (typewriter effect)
    function decodeSubtitle(element, baseText, subtitleText, onComplete) {
      // Check if we should even start typing (page might have changed)
      if (!shouldContinueTyping) {
        console.log('ðŸ›‘ Typing cancelled - page navigation detected');
        return;
      }
      
      // Clear any existing typing animation first
      if (currentTypingInterval) {
        clearInterval(currentTypingInterval);
        currentTypingInterval = null;
        console.log('ðŸ§¹ Cleared previous typing animation');
      }
      
      let charIndex = 0;
      const len = subtitleText.length;
      
      console.log('Starting subtitle typewriter animation...');
      
      currentTypingInterval = setInterval(() => {
        // Check if we should continue typing
        if (!shouldContinueTyping) {
          console.log('ðŸ›‘ Typing cancelled mid-animation');
          clearInterval(currentTypingInterval);
          currentTypingInterval = null;
          return;
        }
        
        // Show characters up to current index
        const currentText = subtitleText.substring(0, charIndex + 1);
        element.textContent = baseText + currentText;
        
        
        charIndex++;
        if (charIndex >= len) {
          clearInterval(currentTypingInterval);
          currentTypingInterval = null;
          element.textContent = baseText + subtitleText; // Final clean text
          console.log('Subtitle typewriter complete');
          if (shouldContinueTyping) { // Only call onComplete if we weren't cancelled
          onComplete && onComplete();
          }
        }
      }, 50); // 50ms per character for smooth typewriter effect
    }
    
    // Function to decode individual timeline lines with scrambling effect
    function decodeTimelineLine(element, baseContent, lineText, onComplete) {
      let index = 0;
      const chunkSize = 15; // Larger chunks for much faster decoding
      const len = lineText.length;
      let scrambled = lineText.split('');
      
      // Initialize scrambled version (keeping spaces and punctuation)
      for (let i = 0; i < len; i++) {
        scrambled[i] = /\s|[:\.\-\[\]#]/.test(lineText[i]) ? lineText[i] : chars[Math.floor(Math.random() * chars.length)];
      }
      
      const lineInterval = setInterval(() => {
        const display = scrambled.slice();
        
        // Reveal chunks progressively
        for (let i = 0; i < index; i++) {
          let s = i * chunkSize, e = Math.min(s + chunkSize, len);
          for (let j = s; j < e; j++) display[j] = lineText[j];
        }
        
        // Keep scrambling the unrevealed part
        for (let k = index * chunkSize; k < len; k++) {
          display[k] = /\s|[:\.\-\[\]#]/.test(lineText[k]) ? lineText[k] : chars[Math.floor(Math.random() * chars.length)];
        }
        
        // Update element with base content + decoded line
        element.textContent = baseContent + display.join('');
        
        
        index++;
        if ((index * chunkSize) >= len) {
          clearInterval(lineInterval);
          element.textContent = baseContent + lineText; // Final clean text
          onComplete && onComplete();
        }
      }, 20); // Much faster decode for individual lines
    }
    
    // Mobile text wrapping function - breaks long lines intelligently while preserving formatting
    function wrapTextForMobile(text) {
      const isMobile = window.innerWidth <= 768;
      if (!isMobile) return text;
      
      const lines = text.split('\n');
      const wrappedLines = [];
      
      for (const line of lines) {
        if (line.length <= 50) {
          // Short lines stay as-is
          wrappedLines.push(line);
        } else {
          // Long lines need wrapping
          const indent = line.match(/^(\s*)/)?.[1] || '';
          const hasBullet = line.match(/^(\s*>\s*)/)?.[1] || '';
          const content = line.replace(/^(\s*>\s*)/, '');
          
          if (content.length <= 50) {
            wrappedLines.push(line);
          } else {
            // Break at natural points (spaces, punctuation)
            const words = content.split(' ');
            let currentLine = indent + hasBullet;
            let isFirstLine = true;
            
            for (const word of words) {
              if ((currentLine + word).length > 45) {
                if (currentLine.trim() !== (indent + hasBullet).trim()) {
                  wrappedLines.push(currentLine);
                  // For continuation lines, only add spaces, not the bullet
                  currentLine = indent + '  ' + word;
                  isFirstLine = false;
                } else {
                  currentLine += word;
                }
              } else {
                currentLine += (currentLine.endsWith(indent + hasBullet) ? '' : ' ') + word;
              }
            }
            
            if (currentLine.trim() !== (indent + hasBullet).trim()) {
              wrappedLines.push(currentLine);
            }
          }
        }
      }
      
      return wrappedLines.join('\n');
    }

    // Function to wrap years in spans for styling
    function wrapYearsInSpans(element) {
      if (!element) return;
      
      // Get the text content
      let text = element.textContent;
      
      // Regular expression to match years in format YYYY: or YYYY-YYYY:
      const yearRegex = /(\d{4}(?:-\d{4})?):/g;
      
      // Replace years with wrapped spans
      const wrappedText = text.replace(yearRegex, '<span class="year-text">$1:</span>');
      
      // Set the innerHTML with the wrapped text
      element.innerHTML = wrappedText;
    }

    function scrambleFastChunks(element, text, onComplete) {
      if (currentInterval) {
clearInterval(currentInterval);
currentInterval = null;
      }
      
      // Apply mobile text wrapping before processing (skip for timeline content)
      if (!element.hasAttribute('data-timeline')) {
        text = wrapTextForMobile(text);
      }
      
      let index = 0, chunkSize = 15, scrambled = text.split(''), len = text.length;
      for (let i=0;i<len;i++) scrambled[i] = /\s/.test(text[i]) ? text[i] : chars[Math.floor(Math.random()*chars.length)];
      isAnimating = true; promptElem.style.visibility='hidden'; navMsg.style.visibility='hidden';


      currentInterval = setInterval(() => {
const display = scrambled.slice();
for (let i=0;i<index;i++){
  let s=i*chunkSize, e=Math.min(s+chunkSize,len);
  for (let j=s;j<e;j++) display[j]=text[j];
}
for (let k=index*chunkSize;k<len;k++) display[k] = /\s/.test(text[k]) ? text[k] : chars[Math.floor(Math.random()*chars.length)];
element.textContent = display.join('');


index++;
if ((index*chunkSize)>=len){
  clearInterval(currentInterval);
  currentInterval = null;
  truncateTextToFit(element, text);
  isAnimating=false;
  
  // Wrap years in spans for styling
  wrapYearsInSpans(element);
  
  // Only show "PRESS SPACEBAR TO CONTINUE" for first 2 pages
  if (currentPage < 2) {
  navMsg.innerHTML='PRESS SPACEBAR<br>TO CONTINUE';
  navMsg.style.fontSize = '0.9rem';
  navMsg.style.visibility='visible';
  }
  
  // Check if this text contains "A FILM BY" and add delayed subtitle
  if (text.includes('A FILM BY EUGENE JARECKI')) {
    console.log('A FILM BY detected - showing video and adding delay...');
    
    // Show JA_OBIWAN video
    showVideo3Background();
    
    // Enable typing for this specific animation
    shouldContinueTyping = true;
    
    // Split the text to separate FILM BY line from 6BDM line
    const lines = text.split('\n');
    const filmByLine = lines.find(line => line.includes('A FILM BY EUGENE JARECKI'));
    const sixBdmLine = lines.find(line => line.includes('6BDM: JULIAN ASSANGE AND THE PRICE OF TRUTH'));
    
    // Show only the FILM BY line immediately
    element.textContent = filmByLine;
    
    // After 20 seconds, type 6BDM and continue to next slide
    const filmByTimeout = setTimeout(() => {
      const subtitleText = '\n\n' + sixBdmLine;
      decodeSubtitle(element, filmByLine, subtitleText, () => {
        onComplete && onComplete();
      });
    }, 20000); // 20 second delay
    filmByTimeouts.push(filmByTimeout);
  } else {
    onComplete && onComplete();
  }
}
      },100);
    }

    // Ultra-fast scrambling specifically for 2006 text - much faster interval
    function scrambleUltraFastChunks(element, text, onComplete) {
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
      }
      
      // Apply mobile text wrapping before processing (skip for timeline content)
      if (!element.hasAttribute('data-timeline')) {
        text = wrapTextForMobile(text);
      }
      
      let index = 0, chunkSize = 15, scrambled = text.split(''), len = text.length;
      for (let i=0;i<len;i++) scrambled[i] = /\s/.test(text[i]) ? text[i] : chars[Math.floor(Math.random()*chars.length)];
      isAnimating = true; promptElem.style.visibility='hidden'; navMsg.style.visibility='hidden';


      currentInterval = setInterval(() => {
        const display = scrambled.slice();
        for (let i=0;i<index;i++){
          let s=i*chunkSize, e=Math.min(s+chunkSize,len);
          for (let j=s;j<e;j++) display[j]=text[j];
        }
        for (let k=index*chunkSize;k<len;k++) display[k] = /\s/.test(text[k]) ? text[k] : chars[Math.floor(Math.random()*chars.length)];
        element.textContent = display.join('');


        index++;
        if ((index*chunkSize)>=len){
          clearInterval(currentInterval);
          currentInterval = null;
          truncateTextToFit(element, text);
          isAnimating=false;
          
          // Wrap years in spans for styling
          wrapYearsInSpans(element);
          
          // Only show "PRESS SPACEBAR TO CONTINUE" for first 2 pages
          if (currentPage < 2) {
            navMsg.innerHTML='PRESS SPACEBAR<br>TO CONTINUE';
            navMsg.style.fontSize = '0.9rem';
            navMsg.style.visibility='visible';
          }
          
          onComplete && onComplete();
        }
      }, 25); // Ultra-fast: 25ms interval instead of 100ms (4x faster)
    }

    /* ================== TIMELINE YEAR-BY-YEAR REVEAL ================== */
    function revealTimelineYearByYear(element, text, onComplete) {
      // Clear any existing animations
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
      }
      
      isAnimating = true;
      isInTimelineRevealMode = true;
      promptElem.style.visibility = 'hidden';
      
      // Split timeline into year sections
      const yearSections = parseTimelineSections(text);
      
      // Set up timeline reveal state
      timelineRevealState = {
        sections: yearSections,
        currentIndex: 0,
        element: element,
        onComplete: onComplete
      };
      
      console.log('Starting year-by-year timeline reveal...');
      console.log(`Total year sections: ${yearSections.length}`);
      
      // Clear element and show first year section with decode animation
      element.textContent = '';
      showNextTimelineSection();
    }
    
    function parseTimelineSections(text) {
      // Split by year patterns (2006:, 2010:, 2011-2012:, etc.)
      const yearPattern = /(\d{4}(-\d{4})?:\s*)/g;
      const sections = [];
      
      // Find all year markers
      const matches = [...text.matchAll(yearPattern)];
      
      if (matches.length === 0) {
        // No year patterns found, return whole text as single section
        return [text];
      }
      
      // Split text at each year marker, including the year marker in each section
      matches.forEach((match, i) => {
        const startIndex = match.index;
        const endIndex = i < matches.length - 1 ? matches[i + 1].index : text.length;
        const sectionText = text.substring(startIndex, endIndex).trim();
        if (sectionText) {
          sections.push(sectionText);
        }
      });
      
      console.log('Parsed timeline sections:', sections.map(s => s.substring(0, 50) + '...'));
      return sections;
    }
    
    function showNextTimelineSection() {
      if (timelineRevealState.currentIndex < timelineRevealState.sections.length) {
        const currentSection = timelineRevealState.sections[timelineRevealState.currentIndex];
        const sectionNumber = timelineRevealState.currentIndex + 1;
        
        console.log(`Showing timeline section ${sectionNumber}: ${currentSection.substring(0, 50)}...`);
        
        if (timelineRevealState.currentIndex === 0) {
          // First section (2006): decode with ultra-fast scrambling animation
          scrambleUltraFastChunks(timelineRevealState.element, currentSection, () => {
            timelineRevealState.currentIndex++;
            // Show navigation message for next section
            if (timelineRevealState.currentIndex < timelineRevealState.sections.length) {
              navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
              navMsg.style.fontSize = '0.9rem';
              navMsg.style.visibility = 'visible';
            } else {
              // All sections revealed
              finishTimelineReveal();
            }
          });
        } else {
          // Subsequent sections: append instantly with single line break
          const currentContent = timelineRevealState.element.textContent;
          timelineRevealState.element.textContent = currentContent + '\n' + currentSection;
          
          // Wrap years in spans for styling
          wrapYearsInSpans(timelineRevealState.element);
          
          console.log(`Timeline section ${sectionNumber} displayed. Current index: ${timelineRevealState.currentIndex}, Total sections: ${timelineRevealState.sections.length}`);
          
          // Increment index after displaying the section
          timelineRevealState.currentIndex++;
          
          // Show navigation message for next section
          if (timelineRevealState.currentIndex < timelineRevealState.sections.length) {
            navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
            navMsg.style.fontSize = '0.9rem';
            navMsg.style.visibility = 'visible';
          } else {
            // All sections revealed - show final navigation message
            console.log('All timeline sections have been displayed');
            navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
            navMsg.style.fontSize = '0.9rem';
            navMsg.style.visibility = 'visible';
            // Don't call finishTimelineReveal() here - let user press spacebar to finish
          }
        }
      } else {
        // No more sections - finish the timeline
        console.log('No more timeline sections, finishing...');
        finishTimelineReveal();
      }
    }
    
    function finishTimelineReveal() {
      console.log('All timeline sections revealed, finishing...');
      isAnimating = false;
      isInTimelineRevealMode = false;
      navMsg.style.visibility = 'hidden';
      timelineRevealState.onComplete && timelineRevealState.onComplete();
    }

    /* ================== LINE BY LINE REVEAL ================== */
    function revealLineByLine(element, text, onComplete) {
      // Clear any existing intervals and timeouts
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
      }
      
      // Clear any existing line reveal timeouts
      lineRevealTimeouts.forEach(timeout => clearTimeout(timeout));
      lineRevealTimeouts = [];
      
      isAnimating = true;
      isInLineRevealMode = true;
      promptElem.style.visibility = 'hidden';
      
      const lines = text.split('\n').filter(line => line.trim() !== ''); // Remove empty lines
      element.textContent = '';
      
      // Set up line reveal state
      lineRevealState = {
        lines: lines,
        currentIndex: 0,
        element: element,
        onComplete: onComplete
      };
      
      console.log('Starting manual line-by-line reveal for 2006-2024 content...');
      console.log(`Total lines to reveal: ${lines.length}`);
      
      // Show the first line immediately
      showNextLineManual();
    }
    
    function showNextLineManual() {
      if (lineRevealState.currentIndex < lineRevealState.lines.length) {
        const currentLine = lineRevealState.lines[lineRevealState.currentIndex];
        const lineNumber = lineRevealState.currentIndex + 1;
        
        // Determine if this line should be decoded (only first line - first item only)
        const shouldDecode = lineRevealState.currentIndex === 0;
        
        if (shouldDecode) {
          console.log(`Decoding line ${lineNumber}: "${currentLine}"`);
          
          // Get current content before this line
          let previousContent = '';
          if (lineRevealState.currentIndex > 0) {
            previousContent = lineRevealState.element.textContent + '\n\n';
          }
          
          // Decode this line with scrambling effect
          decodeTimelineLine(lineRevealState.element, previousContent, currentLine, () => {
            lineRevealState.currentIndex++;
            
            // Check if we're done
            if (lineRevealState.currentIndex >= lineRevealState.lines.length) {
              console.log('All lines revealed, finishing...');
              isAnimating = false;
              isInLineRevealMode = false;
              lineRevealState.onComplete && lineRevealState.onComplete();
            } else {
              // Show navigation message for manual progression (even after decoded lines)
              navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
              navMsg.style.fontSize = '0.9rem';
              navMsg.style.visibility = 'visible';
            }
          });
        } else {
          // Show instantly for later lines (no decoding)
          if (lineRevealState.currentIndex > 0) {
            lineRevealState.element.textContent += '\n\n';
          }
          lineRevealState.element.textContent += currentLine;
          
          console.log(`Instantly revealed line ${lineNumber}: "${currentLine}"`);
          lineRevealState.currentIndex++;
          
          // Show navigation message for manual progression
          navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
          navMsg.style.fontSize = '0.9rem';
          navMsg.style.visibility = 'visible';
          
          if (lineRevealState.currentIndex >= lineRevealState.lines.length) {
            // All lines revealed
            console.log('All lines revealed, finishing...');
            isAnimating = false;
            isInLineRevealMode = false;
            lineRevealState.onComplete && lineRevealState.onComplete();
          }
        }
      }
    }

         /* ================== PAGE RENDER ================== */
  function startPage(pageIndex){
        if (pageIndex >= pages.length) pageIndex = 0;
        if (pageIndex < 0) pageIndex = pages.length - 1;
        currentPage = pageIndex;
        
        console.log(`ðŸ” Starting page ${pageIndex + 1}, content:`, pages[pageIndex] ? pages[pageIndex].substring(0, 100) : 'UNDEFINED');
        
        // Clear any ongoing line reveal timeouts when changing pages
        lineRevealTimeouts.forEach(timeout => clearTimeout(timeout));
        lineRevealTimeouts = [];
        
        // Clear any ongoing 6BDM animation timeouts
        filmByTimeouts.forEach(timeout => clearTimeout(timeout));
        filmByTimeouts = [];
        
        // Clear any ongoing typing animation
        if (currentTypingInterval) {
          clearInterval(currentTypingInterval);
          currentTypingInterval = null;
        }
        
        // Stop any typing animations that might be about to start
        shouldContinueTyping = false;
        
        // Clear any running scrambling animation
        if (currentInterval) {
          clearInterval(currentInterval);
          currentInterval = null;
        }
        
        // Reset animation state
        isAnimating = false;
        
        // Reset line reveal mode
        isInLineRevealMode = false;
        
        // Reset timeline reveal mode
        isInTimelineRevealMode = false;
        
        slideCounterEl.textContent = `SLIDE ${pageIndex + 1} / ${pages.length}`;
        navMsg.style.visibility = 'hidden';
        
        // Set data-page attribute for CSS targeting
        pageEl.setAttribute('data-page', pageIndex + 1);
        
       
      // Use simple, consistent font sizing - smaller on mobile
        const isMobile = window.innerWidth <= 768;
        
        // Check if this is timeline content first
        const pageContent = pages[pageIndex];
        console.log(`ðŸ” Page ${pageIndex + 1} content preview:`, pageContent.substring(0, 100));
        console.log(`ðŸ” Page ${pageIndex + 1} full content:`, pageContent);
        const isTimelineContent = pageContent.includes('2006:') || 
                                 pageContent.includes('2010:') || 
                                 pageContent.includes('2011-2012:') || 
                                 pageContent.includes('2017:') || 
                                 pageContent.includes('2017-2024:') || 
                                 pageContent.includes('2024:') || 
                                 pageContent.includes('RETURNED TO AUSTRALIA') ||
                                 pageContent.includes('CANNES FILM FESTIVAL') ||
                                 pageContent.includes('LEADING INFLUENCER') ||
                                 pageContent.includes('GLOBAL AUDIENCE');
        console.log(`ðŸ” Page ${pageIndex + 1} is timeline content:`, isTimelineContent);
        
        if (isTimelineContent) {
          // Make timeline content 25% smaller
          el.style.fontSize = isMobile ? '0.6rem' : '0.9rem';
          
          // Mark as timeline content for CSS protection
          el.setAttribute('data-timeline', 'true');
          
          // Preserve exact formatting for timeline content - prevent any text modifications
          el.style.whiteSpace = 'pre-wrap';
          el.style.wordWrap = 'normal';
          el.style.overflowWrap = 'normal';
          el.style.hyphens = 'none';
          el.style.textIndent = '0';
          el.style.wordBreak = 'normal';
          el.style.lineHeight = '1.5';
          
        } else {
          // Normal text size
        el.style.fontSize = isMobile ? '0.8rem' : '1.2rem';
          
          // Remove timeline marker
          el.removeAttribute('data-timeline');
          
          // Reset any timeline-specific formatting
          el.style.whiteSpace = '';
          el.style.wordWrap = '';
          el.style.overflowWrap = '';
          el.style.hyphens = '';
          el.style.textIndent = '';
          el.style.wordBreak = '';
          el.style.lineHeight = '';
        }
        
        el.style.paddingBottom = ''; // Reset any padding
       
       // Show text for all pages
       if (pageIndex < pages.length) {
         const textWrap = document.getElementById('text-wrap');
         if (textWrap) {
           textWrap.style.display = 'block';
         }
         
         el.textContent='';
         isAnimating = false;
         
         // Remove any existing animation classes
         el.classList.remove('collateral-murder-slide');
         
         // Check if this is the Collateral Murder video slide
         const isCollateralMurderSlide = pages[pageIndex].includes('It published the infamous Collateral Murder video in 2010');
         
         if (isTimelineContent) {
          // For timeline content, use year-by-year reveal system
          console.log('Timeline content detected, starting year-by-year reveal');
          
          // Use the new year-by-year timeline reveal
          revealTimelineYearByYear(el, pages[pageIndex], () => {
             // Timeline reveal complete
            console.log('Timeline year-by-year reveal completed');
           });
         } else {
          // Use faster scrambling for page 0
          if (pageIndex === 0) {
            // Instant display for page 0 to speed up initial load
            el.textContent = isMobile ? wrapTextForMobile(pages[pageIndex]) : pages[pageIndex];
            // Wrap years in spans for styling
            wrapYearsInSpans(el);
             // Call the callback immediately
             if (isCollateralMurderSlide) {
               console.log('Collateral Murder slide detected, starting animation...');
               setTimeout(() => {
                 el.classList.add('collateral-murder-slide');
                 console.log('Animation class added');
                 setTimeout(() => {
                   createPersistentText();
                   console.log('Persistent text created');
                 }, 3000);
               }, 1000);
             }
         } else {
           scrambleFastChunks(el, pages[pageIndex], () => {
           // Text displayed
           if (isCollateralMurderSlide) {
             console.log('Collateral Murder slide detected, starting animation...');
             // Add animation class after text is fully displayed
             setTimeout(() => {
               el.classList.add('collateral-murder-slide');
               console.log('Animation class added');
               
               // After animation completes, create a persistent copy
               setTimeout(() => {
                 createPersistentText();
                 console.log('Persistent text created');
               }, 3000); // After 3 second animation
             }, 1000); // Wait 1 second after text is displayed
           }
         });
           }
         }
       }
       
       showImage(pageIndex);
       
       // Handle last slide - add collateral image and audio
       if (pageIndex === pages.length - 1) {
         console.log('Last slide detected - adding collateral image and audio');
         
         // Clear any existing last slide elements
         const existingContainer = document.getElementById('last-slide-image-container');
         const existingAudio = document.getElementById('last-slide-audio');
         if (existingContainer) existingContainer.remove();
         if (existingAudio) existingAudio.remove();
         
         // Create container for image with effects
         const imageContainer = document.createElement('div');
         imageContainer.id = 'last-slide-image-container';
         imageContainer.style.cssText = `
           position: fixed;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           max-width: 80vw;
           max-height: 80vh;
           z-index: 1;
           pointer-events: none;
           overflow: hidden;
         `;
         document.body.appendChild(imageContainer);
         
         // Add image with proper visual effects (matching lorem_new.html)
         const img = document.createElement('img');
         img.id = 'last-slide-image';
         img.src = 'PHOTOS/photo_collateral.jpg';
         img.style.cssText = `
           width: 100%;
           height: 100%;
           object-fit: contain;
           filter: brightness(0.7) sepia(1) hue-rotate(60deg) saturate(1.5);
         `;
         imageContainer.appendChild(img);
         
         // Add audio to body (more persistent)
         const audio = document.createElement('audio');
         audio.id = 'last-slide-audio';
         audio.src = 'AUDIO/COLLATERAL_AUDIO.mp4';
         audio.autoplay = true;
         audio.loop = true;
         audio.volume = 0.7;
         audio.style.cssText = 'position: fixed; bottom: 0; left: 0; z-index: 1000;';
         document.body.appendChild(audio);
         
         audio.play().catch(err => {
           console.log('Last slide audio autoplay failed:', err);
         });
       } else {
         // Clean up when not on last slide
         const existingContainer = document.getElementById('last-slide-image-container');
         const existingAudio = document.getElementById('last-slide-audio');
         if (existingContainer) existingContainer.remove();
         if (existingAudio) existingAudio.remove();
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 7) {
         console.log('ðŸ”‡ Audio disabled for page 7');
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 10) {
         console.log('ðŸ”‡ Audio disabled for page 10');
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 9) {
         console.log('ðŸ”‡ Audio disabled for page 9');
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 13) {
         console.log('ðŸ”‡ Audio disabled for page 13');
       }
       
      // Audio disabled - no sounds
      if (pageIndex + 1 === 15) {
        console.log('ðŸ”‡ Audio disabled for page 15');
      }
       
       // Show video on slide 15
       console.log(`ðŸ” Debug: Current page ${pageIndex + 1}, checking for video on slide 15...`);
       if (pageIndex + 1 === 15) {
         console.log('ðŸŽ¬ SLIDE 15 - Showing video...');
         showVideoBackground();
         // Hide video2 when showing video15
         hideVideo2Background();
       } else {
         console.log(`ðŸŽ¬ Not slide 15 (current: ${pageIndex + 1}), hiding video...`);
         // Hide video on other pages
         hideVideoBackground();
       }
       
       // Show video2 on slide 2
       console.log(`ðŸ” Debug: Current page ${pageIndex + 1}, checking for video2 on slide 2...`);
       if (pageIndex + 1 === 2) {
         console.log('ðŸŽ¬ SLIDE 2 - Showing video2...');
         showVideo2Background();
       } else {
         console.log(`ðŸŽ¬ Not slide 2 (current: ${pageIndex + 1}), hiding video2...`);
         // Hide video2 on other pages
         hideVideo2Background();
       }
       
       // Show video3 on 6BDM slide (only the main 6BDM slide with timeline content)
       if (pageContent.includes('6BDM: JULIAN ASSANGE AND THE PRICE OF TRUTH')) {
         console.log('ðŸŽ¬ 6BDM slide - Showing video3...');
         showVideo3Background();
       } else {
         console.log(`ðŸŽ¬ Not 6BDM slide, hiding video3...`);
         hideVideo3Background();
       }
     }

    // Create persistent text that stays on screen
    function createPersistentText() {
      // Remove any existing persistent text
      const existing = document.getElementById('persistent-text');
      if (existing) {
        existing.remove();
      }
      
      // Create new persistent text element
      const persistentDiv = document.createElement('div');
      persistentDiv.id = 'persistent-text';
      
      const textContent = document.createElement('div');
      textContent.className = 'text-content';
      textContent.textContent = 'It published the infamous Collateral Murder video in 2010';
      
      persistentDiv.appendChild(textContent);
      document.body.appendChild(persistentDiv);
     }

    /* ================== NAV ================== */
    let lastAdvance = 0;
    function throttle(){ const now=Date.now(); if (now-lastAdvance<300) return false; lastAdvance=now; return true; }
    function safeAdvance(){ if (!throttle()) return; unlockAudioContext(); startPage(currentPage+1); }
    function goBack(){ if (!throttle()) return; unlockAudioContext(); startPage(currentPage-1); }

    document.getElementById('nav-prev').addEventListener('pointerdown', goBack, {passive:true});
    document.getElementById('nav-next').addEventListener('pointerdown', safeAdvance, {passive:true});
    document.getElementById('nav-prev').addEventListener('touchstart', goBack, {passive:true});
    document.getElementById('nav-next').addEventListener('touchstart', safeAdvance, {passive:true});
    document.getElementById('nav-prev').addEventListener('click', goBack);
    document.getElementById('nav-next').addEventListener('click', safeAdvance);
 document.addEventListener('pointerdown', (e)=>{ 
      if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
      
      // Unlock audio context on pointer interaction
      unlockAudioContext();
      
      // If in timeline reveal mode, only handle mouse events (let touch events be handled by touchend)
      if (isInTimelineRevealMode) {
        // Only handle mouse events, not touch events
        if (e.pointerType === 'mouse') {
          showNextTimelineSection();
        }
        return;
      }
      
      // If in line reveal mode, clicking anywhere advances to next line
      if (isInLineRevealMode) {
        showNextLineManual();
        return;
      }
      
      // Normal mode: Left half of screen goes back, right half goes forward
      if (e.clientX < window.innerWidth / 2) {
        goBack();
      } else {
        safeAdvance();
      }
    }, {passive:true});
     
     document.addEventListener('touchstart', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       const now = Date.now();
       // Debounce touch events to prevent double-firing
       if (now - lastTouchTime < 200) return;
       lastTouchTime = now;
       
       // Unlock audio context on mobile touch
       unlockAudioContext();
       
       // If in timeline reveal mode, just prevent default and return (let touchend handle it)
       if (isInTimelineRevealMode) {
         e.preventDefault(); // Prevent default touch behavior
         return;
       }
       
       // If in line reveal mode, tapping anywhere advances to next line
       if (isInLineRevealMode) {
         e.preventDefault(); // Prevent default touch behavior
         showNextLineManual();
         return;
       }
       
       // Normal mode: Left half of screen goes back, right half goes forward
       if (e.touches[0].clientX < window.innerWidth / 2) {
         goBack();
       } else {
         safeAdvance();
       }
     }, {passive:false}); // Changed to passive:false to allow preventDefault
     
     // Add touchend event handler for better mobile responsiveness  
     document.addEventListener('touchend', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       const now = Date.now();
       // Debounce touch events to prevent double-firing
       if (now - lastTouchTime < 200) return;
       lastTouchTime = now;
       
       // Unlock audio context on mobile touch
       unlockAudioContext();
       
       // If in timeline reveal mode, only right side advances to next year section
       if (isInTimelineRevealMode) {
         console.log('Mobile touchend: Timeline reveal mode detected, checking right side tap');
         e.preventDefault(); // Prevent default touch behavior
         if (e.changedTouches[0].clientX >= window.innerWidth / 2) {
           showNextTimelineSection();
         }
         return;
       }
       
       // If in line reveal mode, tapping anywhere advances to next line
       if (isInLineRevealMode) {
         e.preventDefault(); // Prevent default touch behavior
         showNextLineManual();
         return;
       }
     }, {passive:false});
document.addEventListener('click', (e)=>{ 
      if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
      
      const now = Date.now();
      // Prevent click events that follow touch events too closely
      if (now - lastTouchTime < 300) return;
      
      // If in timeline reveal mode, just prevent default and return (let touchend handle it)
      if (isInTimelineRevealMode) {
        e.preventDefault(); // Prevent any default click behavior
        return;
      }
      
      // If in line reveal mode, clicking anywhere advances to next line
      if (isInLineRevealMode) {
        e.preventDefault(); // Prevent any default click behavior
        showNextLineManual();
        return;
      }
      
      // Normal mode: Left half of screen goes back, right half goes forward
      if (e.clientX < window.innerWidth / 2) {
        goBack();
      } else {
        safeAdvance();
      }
    });

    // Simplified font system
    let currentFontIndex = 3; // Start with Crisp (index 3) as default
    let currentFontSize = 1.0; // Size multiplier (1.0 = 100% of base size)
    const fonts = [
      { family: 'Courier New', size: '1.2rem' },
      { family: 'IBM3270', size: '1.2rem' },
      { family: 'PixelCarnageMono', size: '1.2rem' },
      { family: 'Crisp', size: '1.2rem' },
      { family: 'ProggyCleanCE', size: '1.2rem' },
      { family: 'ProggySquare', size: '1.2rem' }
    ];
    
    function cycleFontForward() {
      currentFontIndex = (currentFontIndex + 1) % fonts.length;
      applyCurrentFont();
    }
    
    function cycleFontBackward() {
      currentFontIndex = (currentFontIndex - 1 + fonts.length) % fonts.length;
      applyCurrentFont();
    }
    
             function applyCurrentFont() {
      const selectedFont = fonts[currentFontIndex];
      console.log('Applying font:', selectedFont);
      
      // Update the CSS custom property
      document.documentElement.style.setProperty('--font-family', selectedFont.family);
      
      // Apply font family to all text elements
      const allTextElements = document.querySelectorAll('#unscramble, #prompt, #nav-msg, #nav-prev, #nav-next, #slide-counter');
      allTextElements.forEach(el => {
        if (el) {
          el.style.fontFamily = selectedFont.family;
        }
      });
      
      // Also apply to body to ensure all elements inherit the font
      document.body.style.fontFamily = selectedFont.family;
      
      console.log(`Font changed to: ${selectedFont.family}`);
    }

    window.addEventListener('keydown', (e) => {
      // Mute any keyboard sounds
      e.preventDefault();
      
      // Check if we're in timeline reveal mode first
      if (isInTimelineRevealMode && (e.code==='Space'||e.code==='ArrowRight')) {
        showNextTimelineSection();
        return;
      }
      
      // Check if we're in line reveal mode
      if (isInLineRevealMode && (e.code==='Space'||e.code==='ArrowRight')) {
        showNextLineManual();
        return;
      }
      
      if (e.code==='Space'||e.code==='ArrowRight'){ unlockAudioContext(); startPage(currentPage+1); }
      else if (e.code==='ArrowLeft'){ unlockAudioContext(); startPage(currentPage-1); }

      const k = e.key;
     if (k==='ArrowUp'){ 
 pageModes[currentPage]=getNextImageMode(pageModes[currentPage]); 
 markUserSetMode(currentPage); 
 showImage(currentPage); 
       }
       else if (k==='ArrowDown'){ 
 pageModes[currentPage]=getPreviousImageMode(pageModes[currentPage]); 
 markUserSetMode(currentPage); 
 showImage(currentPage); 
       }
      // Font cycling removed - using fixed font system
      else if (k==='l'||k==='L'){ 
pageModes[currentPage]=IMG_BELOW; 
markUserSetMode(currentPage); 
showImage(currentPage); 
      }
     else if (k==='s'||k==='S'){ 
pageModes[currentPage]=IMG_SIDE; 
markUserSetMode(currentPage); 
showImage(currentPage); 
adjustTextForSideImage(); 
      }
       else if (k==='a'||k==='A'){ 
pageModes[currentPage]=IMG_SMALL_SIDE; 
markUserSetMode(currentPage); 
showImage(currentPage); 
adjustTextForSideImage(); 
      }
       else if (k==='o'||k==='O'){ 
pageModes[currentPage]=IMG_OFF; 
markUserSetMode(currentPage); 
showImage(currentPage); 
resetTextContainer(); 
      }
      else if (k==='z'||k==='Z'){ toggleGreenOverlay('full'); }
      else if (k==='x'||k==='X'){ toggleGreenOverlay('half'); }
      else if (k==='c'||k==='C'){ toggleGreenOverlay('off'); }
      else if (k==='f'||k==='F'){ toggleFullscreen(); }
      else if (k==='a'||k==='A'){ 
        console.log('ðŸ§ª A key pressed - testing audio...');
        testAudio();
      }
      else if (k==='v'||k==='V'){ 
        console.log('ðŸ§ª V key pressed - testing video...');
        showVideoBackground();
      }
      else if (k==='h'||k==='H'){ 
        console.log('ðŸ§ª H key pressed - hiding video...');
        hideVideoBackground();
      }
      else if (k==='2'||k==='2'){ 
        console.log('ðŸ§ª 2 key pressed - testing video2...');
        showVideo2Background();
      }
      else if (k==='j'||k==='J'){ 
        console.log('ðŸ§ª J key pressed - hiding video2...');
        hideVideo2Background();
      }
    });
    
    // Fullscreen functionality
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
document.documentElement.requestFullscreen().catch(err => {
  console.log(`Error attempting to enable fullscreen: ${err.message}`);
});
      } else {
document.exitFullscreen();
      }
    }

    /* ================== COLOR/GLOW ================== */
    (function(){
      const navPrev = document.getElementById('nav-prev');
      const navNext = document.getElementById('nav-next');
      const terminals = [document.getElementById('unscramble'), document.getElementById('prompt'), document.getElementById('nav-msg'), navPrev, navNext, document.getElementById('slide-counter')];
      let colorIndex=2; // Default to soft green (option 3)
      const colors=['#CCCCCC','#00FF00','#66FF66'];
      function apply(){
terminals.forEach(el=>{ if(!el) return;
  el.style.color = colors[colorIndex];
  el.style.textShadow = `0 0 2px ${colors[colorIndex]}, 0 0 12px ${colors[colorIndex]}`; // Glow always on
});

// Update cursor color to match
const customCursor = document.getElementById('custom-cursor');
if (customCursor) {
  customCursor.style.background = colors[colorIndex];
  customCursor.style.boxShadow = `0 0 2px ${colors[colorIndex]}, 0 0 12px ${colors[colorIndex]}`;
}
      }
      document.addEventListener('keydown', (e)=>{
if (e.key==='1'||e.key==='2'||e.key==='3'){ colorIndex=parseInt(e.key,10)-1; apply(); }
      });
      apply();
    })();

    /* ================== INIT ================== */
    window.onload = () => {
      // Start presentation immediately when DOM is loaded
      startPage(0);
      
      // Initialize audio context for mobile devices
      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        console.log('ðŸ“± Mobile device detected - preparing audio context');
        // Pre-initialize audio context on mobile
        initAudioContext();
      }
      
      // Mute all audio by default
      document.addEventListener('keydown', (e) => {
        e.preventDefault();
      });
      
      // Mute all audio elements by default
      document.querySelectorAll('audio, video').forEach(media => {
        media.muted = true;
        media.volume = 0;
      });
      
      // Video will only show on page 15 via the page navigation logic
      // Hide any images that fail to load
      document.querySelectorAll('#page img').forEach(img => {
img.addEventListener('error', () => {
  img.style.display = 'none';
});
      });
      
      // Custom cursor functionality
      const customCursor = document.getElementById('custom-cursor');
      
      document.addEventListener('mousemove', (e) => {
customCursor.style.display = 'block';
customCursor.style.left = e.clientX - 10 + 'px';
customCursor.style.top = e.clientY - 10 + 'px';
      });
      
      document.addEventListener('mouseleave', () => {
customCursor.style.display = 'none';
      });
      
      // Apply the default font (IBM3270) on page load
      applyCurrentFont();
    };
    
    // Global green overlay toggle function
    let currentOverlayMode = 'full'; // Track current overlay mode - default to full green
    
    function toggleGreenOverlay(mode) {
      currentOverlayMode = mode; // Store the current mode
      const images = document.querySelectorAll('#page img');
      images.forEach(img => {
applyOverlayToImage(img, mode);
      });
      
    }
    
       // Apply overlay to a specific image
      function applyOverlayToImage(img, mode) {
// Check if this is photo23 (which should stay dimmed) or page 10 images (which should be darker)
const isDimmedPhoto = img.id === 'img-23';
const isDarkerPhoto = img.id.startsWith('img-10');
const baseBrightness = isDarkerPhoto ? 0.35 : (isDimmedPhoto ? 0.32 : 0.64);

if (mode === 'full') {
  img.style.filter = `grayscale(1) brightness(${baseBrightness}) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2)`;
} else if (mode === 'half') {
  img.style.filter = `brightness(${baseBrightness}) grayscale(1)`;
} else if (mode === 'off') {
  img.style.filter = `brightness(${baseBrightness})`;
}
      }
    
     
     
  </script>
  
  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/OutputPass.js"></script>
  
  <!-- Shaders for 3D Audio Visualizer -->
  <script id="vertexshader" type="vertex">
    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
      return mod289(((x*34.0)+10.0)*x);
    }

    vec4 taylorInvSqrt(vec4 r) {
      return 1.79284291400159 - 0.85373472095314 * r;
    }

    vec3 fade(vec3 t) {
      return t*t*t*(t*(t*6.0-15.0)+10.0);
    }

    float pnoise(vec3 P, vec3 rep) {
      vec3 Pi0 = mod(floor(P), rep);
      vec3 Pi1 = mod(floor(P) + vec3(1.0), rep);
      Pi0 = mod289(Pi0);
      Pi1 = mod289(Pi1);
      vec3 Pf0 = fract(P);
      vec3 Pf1 = Pf0 - vec3(1.0);
      vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
      vec4 iy = vec4(Pi0.yy, Pi1.yy);
      vec4 iz0 = vec4(Pi0.z);
      vec4 iz1 = vec4(Pi1.z);

      vec4 ixy = permute(permute(ix) + iy);
      vec4 ixy0 = permute(ixy + iz0);
      vec4 ixy1 = permute(ixy + iz1);

      vec4 gx0 = ixy0 * (1.0 / 7.0);
      vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
      gx0 = fract(gx0);
      vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
      vec4 sz0 = step(gz0, vec4(0.0));
      gx0 -= sz0 * (step(0.0, gx0) - 0.5);
      gy0 -= sz0 * (step(0.0, gy0) - 0.5);

      vec4 gx1 = ixy1 * (1.0 / 7.0);
      vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
      gx1 = fract(gx1);
      vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
      vec4 sz1 = step(gz1, vec4(0.0));
      gx1 -= sz1 * (step(0.0, gx1) - 0.5);
      gy1 -= sz1 * (step(0.0, gy1) - 0.5);

      vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
      vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
      vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
      vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
      vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
      vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
      vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
      vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

      vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
      g000 *= norm0.x;
      g010 *= norm0.y;
      g100 *= norm0.z;
      g110 *= norm0.w;
      vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
      g001 *= norm1.x;
      g011 *= norm1.y;
      g101 *= norm1.z;
      g111 *= norm1.w;

      float n000 = dot(g000, Pf0);
      float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
      float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
      float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
      float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
      float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
      float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
      float n111 = dot(g111, Pf1);

      vec3 fade_xyz = fade(Pf0);
      vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
      vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
      float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
      return 2.2 * n_xyz;
    }

    uniform float u_time;
    uniform float u_frequency;
    uniform float u_red;
    uniform float u_green;
    uniform float u_blue;

    void main() {
      float noise = 3.0 * pnoise(position + u_time, vec3(10.0));
      float displacement = (u_frequency / 30.0) * (noise / 10.0);
      vec3 newPosition = position + normal * displacement;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
    }
  </script>

  <script id="fragmentshader" type="fragment">
    uniform float u_red;
    uniform float u_green;
    uniform float u_blue;
    
    void main() {
      gl_FragColor = vec4(vec3(u_red, u_green, u_blue), 1.0);
    }
  </script>
  
</body>
</html>
  